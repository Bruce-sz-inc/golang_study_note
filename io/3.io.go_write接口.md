首先，strings包里面的reader.go文件并没有write（有WriteTo），所以我们需要到别的地方去找这个接口的实现。  
最简单的就是文件操作的代码里面了，因为涉及到文件必然有写的操作。  
所以我们在os包的file.go文件里找到了它的实现：  
```go
func (f *File) Write(b []byte) (n int, err error) {
	if err := f.checkValid("write"); err != nil {
		return 0, err
	}
	n, e := f.write(b)
	if n < 0 {
		n = 0
	}
	if n != len(b) {
		err = io.ErrShortWrite
	}

	epipecheck(f, e)

	if e != nil {
		err = &PathError{"write", f.name, e}
	}
	return n, err
}
```
接下来，我们写一段例子来实现它。  
```go
func main()  {
	f, err := os.OpenFile("test.txt",os.O_RDWR|os.O_CREATE|os.O_APPEND,os.ModePerm)
	if(err!=nil){
		fmt.Println(err)
	}
	f.Write([]byte(string("hello mama miya")))
	fmt.Println(f)
}
result:
创建了一个test.txt，并成功将hello mama miya写入
```

注意的是，在Write内部，还调用了writes这个私有方法。  
```go
// write writes len(b) bytes to the File.
// It returns the number of bytes written and an error, if any.
func (f *File) write(b []byte) (n int, err error) {
	f.l.Lock()
	defer f.l.Unlock()
	if f.isConsole {
		return f.writeConsole(b)
	}
	return fixCount(syscall.Write(f.fd, b))
}
```
虽然已经超出了io包的范畴，不过也可以简单得说下。
*File也是一个结构

```go
type file struct {
	fd      syscall.Handle
	name    string
	dirinfo *dirInfo   // nil unless directory being read
	l       sync.Mutex // used to implement windows pread/pwrite

	// only for console io
	isConsole      bool
	lastbits       []byte   // first few bytes of the last incomplete rune in last write
	readuint16     []uint16 // buffer to hold uint16s obtained with ReadConsole
	readbyte       []byte   // buffer to hold decoding of readuint16 from utf16 to utf8
	readbyteOffset int      // readbyte[readOffset:] is yet to be consumed with file.Read
}
```
这是windows版的定义，linux版还不知道。这里的l是一个锁。  
在写文件的时候，会上锁，写完，会解锁。  

