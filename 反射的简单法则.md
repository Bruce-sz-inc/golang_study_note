
## 原文标题为：The Laws of Reflection

### 简介

在计算机中，反射是一程序去检查自己结构、特殊的通过类型的能力。它来自于元编程，它也是一种混乱的根源。  

在这篇文章中，我们试图通过解释在GO中反射是怎么运作的，从而将其理清。每个语言的反射模式都是不同的（当然，也有很多语言并不支持反射），但是这篇文章只涉及到Go，所以在这篇文章中的“reflection”就只是意味着“reflection in Go”

### Types and interfaces（这两个单词不太好翻，类型和接口）

因为反映建立在类型系统上，让我们来复习一下Go中的types。

Go是一种静态的类型。每一个变量都有一个静态的类型,也即而言，在编译周期中一个已知和固定的类型：int（整形），float32（浮点），*MyType（指针）, []byte（比特），诸如此类。如果我们声明：

```go
type MyInt int

var i int
var j MyInt
```

那么i是整数类型，j便是自定义的MyInt类型。这变量i和j都有一个很清晰的静态类型，以及，虽然它们有一个同样的下层类型（也就是最终都是int），但它们并不能在未经过转换的情况下进行互相赋值的操作 

在变量类型中，一个很重要的种类是接口类型，它能用来表示方法的固定集合。一个接口变量能存储任意的有形、实在的（非接口）值，如果这个值是实现了接口的抽象方法的话。一个众所周知的成双例子是io.Reader和io.Writer，这两个类型是源自于io包中的读和写的类型：

```
// Reader is the interface that wraps the basic Read method.
type Reader interface {
    Read(p []byte) (n int, err error)
}

// Writer is the interface that wraps the basic Write method.
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

任何类型，只要是实现了读（或写）的带此签名的方法，就意味着实现了io.Reader (or io.Writer)。讨论的目的，在于意味着类型io.Reader变量能保存任何一个实现了Read方法的类型中：

```
var r io.Reader
r = os.Stdin
r = bufio.NewReader(r)
r = new(bytes.Buffer)
// and so on
```
这里面非常之重要的一点是要明白无论具体值r如何被保持（存），r的类型始终是io.Reader：Go是一种静态的类型，而r的静态的类型就是io.Reader。

一个关于接口类型的非常重要的例子就是空接口：

```
interface{}
```

它表示空的方法集合，并且完全可以满足任何值，因为任何值都有零方法，或是多个方法。

一些人说，Go接口是动态的类型，但是那是具有误导性的。它们是静态的类型：接口类型的变量总是同样的静态类型，即使是在运行周期值被存储在接口变量并可以改变类型，但是值将永远满足接口。

我们需要对这些内容非常的清晰，因为反射和接口两者之间的关联相当紧密。

###接口的表现

