 
## 原文标题为：The Laws of Reflection

### 简介

在计算机中，反射是一程序去检查自己结构、特殊的通过类型的能力。它来自于元编程，它也是一种混乱的根源。  

在这篇文章中，我们试图通过解释在GO中反射是怎么运作的，从而将其理清。每个语言的反射模式都是不同的（当然，也有很多语言并不支持反射），但是这篇文章只涉及到Go，所以在这篇文章中的“reflection”就只是意味着“reflection in Go”

### Types and interfaces（这两个单词不太好翻，类型和接口）

因为反映建立在类型系统上，让我们来复习一下Go中的types。

Go是一种静态的类型。每一个变量都有一个静态的类型,也即而言，在编译周期中一个已知和固定的类型：int（整形），float32（浮点），*MyType（指针）, []byte（比特），诸如此类。如果我们声明：

```go
type MyInt int

var i int
var j MyInt
```

那么i是整数类型，j便是自定义的MyInt类型。这变量i和j都有一个很清晰的静态类型，以及，虽然它们有一个同样的下层类型（也就是最终都是int），但它们并不能在未经过转换的情况下进行互相赋值的操作 

在变量类型中，一个很重要的种类是接口类型，它能用来表示方法的固定集合。一个接口变量能存储任意的有形、实在的（非接口）值，如果这个值是实现了接口的抽象方法的话。一个众所周知的成双例子是io.Reader和io.Writer，这两个类型是源自于io包中的读和写的类型：

```
// Reader is the interface that wraps the basic Read method.
type Reader interface {
    Read(p []byte) (n int, err error)
}

// Writer is the interface that wraps the basic Write method.
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

任何类型，只要是实现了读（或写）的带此签名的方法，就意味着实现了io.Reader (or io.Writer)。讨论的目的，在于意味着类型io.Reader变量能保存任何一个实现了Read方法的类型中：

```
var r io.Reader
r = os.Stdin
r = bufio.NewReader(r)
r = new(bytes.Buffer)
// and so on
```
这里面非常之重要的一点是要明白无论具体值r如何被保持（存），r的类型始终是io.Reader：Go是一种静态的类型，而r的静态的类型就是io.Reader。

一个关于接口类型的非常重要的例子就是空接口：

```
interface{}
```

它表示空的方法集合，并且完全可以满足任何值，因为任何值都有零方法，或是多个方法。

一些人说，Go接口是动态的类型，但是那是具有误导性的。它们是静态的类型：接口类型的变量总是同样的静态类型，即使是在运行周期值被存储在接口变量并可以改变类型，但是值将永远满足接口。

我们需要对这些内容非常的清晰，因为反射和接口两者之间的关联相当紧密。

### 接口的陈述

程序员Russ Cox写了一篇很详细的关于Go中的接口值的陈述的博客文章。我们并不需要再去完整地在此重复一遍，但是还是需要有条理地简单的归纳一下。
```
注：这篇文章的地址是：http://research.swtch.com/2009/12/go-data-structures-interfaces.html
不过已经打不开了。
```

接口类型的变量会存储两部分内容：变量的具体值，和这个值的类型的具体描述符。为了更精确一些，这个值的底层具体数据项实现了接口，并且类型描述了此项的完整个类型。后面举个例子
A variable of interface type stores a pair: the concrete value assigned to the variable, and that value's type descriptor. To be more precise, the value is the underlying concrete data item that implements the interface and the type describes the full type of that item. For instance, after

```
var r io.Reader
tty, err := os.OpenFile("/dev/tty", os.O_RDWR, 0)
if err != nil {
    return nil, err
}
r = tty
```

r计划性地包含了对偶（值，类型）->`（tty,*os.File）`。注意类型`*os.File`是实现了Read的方法；即使接口值只提供了读方法的入口，这个值的内部携带了它的类型的所有的信息。这就是为什么我们可以做下面这些事情：
r contains, schematically, the (value, type) pair, (tty, *os.File). Notice that the type *os.File implements methods other than Read; even though the interface value provides access only to the Read method, the value inside carries all the type information about that value. That's why we can do things like this:

```
var w io.Writer
w = r.(io.Writer)
```
这个任务的语句是一个类型声明；它分派了r变量的项目也是从io.Writer中实现的，同样，我们也能分派它给变量w。在指派之后，w将包含对偶属性`（tty,*os.File)`。这和r所持有的对偶属性是相同的。这个接口的静态类型决定接口变量中的哪个方法可以被唤醒，即使这个具体的值内部有很多的方法集合。
The expression in this assignment is a type assertion; what it asserts is that the item inside r also implements io.Writer, and so we can assign it to w. After the assignment, w will contain the pair (tty, *os.File). That's the same pair as was held in r. The static type of the interface determines what methods may be invoked with an interface variable, even though the concrete value inside may have a larger set of methods.

继续，我们能这样做：
Continuing, we can do this:

```
var empty interface{}
empty = w
```
我们的空接口的值是空的，将再次包含同样的对偶属性`(tty, *os.File)`。这方便之处在于：一个空接口能持有任何值，能包含我们所需要的关于这个值的任何信息。
and our empty interface value empty will again contain that same pair, (tty, *os.File). That's handy: an empty interface can hold any value and contains all the information we could ever need about that value.

（这里我们可以不需要类型声明，因为它是已知的静态的，w满足空类型。在例子中，我们移动a Reader到a Writer,我们需要切割和使用类型声明，因为Writer这个方法不是Reader的子集合。）
(We don't need a type assertion here because it's known statically that w satisfies the empty interface. In the example where we moved a value from a Reader to a Writer, we needed to be explicit and use a type assertion because Writer's methods are not a subset of Reader's.)

One important detail is that the pair inside an interface always has the form (value, concrete type) and cannot have the form (value, interface type). Interfaces do not hold interface values.

现在我们来读一下反射。
Now we're ready to reflect.

### 反射的第一定律
### The first law of reflection

#### 1. Reflection goes from interface value to reflection object.

At the basic level, reflection is just a mechanism to examine the type and value pair stored inside an interface variable. To get started, there are two types we need to know about in package reflect: Type and Value. Those two types give access to the contents of an interface variable, and two simple functions, called reflect.TypeOf and reflect.ValueOf, retrieve reflect.Type and reflect.Value pieces out of an interface value. (Also, from the reflect.Value it's easy to get to the reflect.Type, but let's keep the Value and Type concepts separate for now.)

Let's start with TypeOf:

```
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float64 = 3.4
    fmt.Println("type:", reflect.TypeOf(x))
}
```

这段程序打印出
This program prints

```
type: float64
```

You might be wondering where the interface is here, since the program looks like it's passing the float64 variable x, not an interface value, to reflect.TypeOf. But it's there; as godoc reports[https://golang.org/pkg/reflect/#TypeOf], the signature of reflect.TypeOf includes an empty interface:

```
// TypeOf returns the reflection Type of the value in the interface{}.
func TypeOf(i interface{}) Type
```

When we call reflect.TypeOf(x), x is first stored in an empty interface, which is then passed as the argument; reflect.TypeOf unpacks that empty interface to recover the type information.

The reflect.ValueOf function, of course, recovers the value (from here on we'll elide the boilerplate and focus just on the executable code):

```
var x float64 = 3.4
fmt.Println("value:", reflect.ValueOf(x).String())
```

打印出
prints

```
value: <float64 Value>
```

(We call the String method explicitly because by default the fmt package digs into a reflect.Value to show the concrete value inside. The String method does not.)

Both reflect.Type and reflect.Value have lots of methods to let us examine and manipulate them. One important example is that Value has a Type method that returns the Type of a reflect.Value. Another is that both Type and Value have a Kind method that returns a constant indicating what sort of item is stored: Uint, Float64, Slice, and so on. Also methods on Value with names like Int and Float let us grab values (as int64 and float64) stored inside:

```
var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println("type:", v.Type())
fmt.Println("kind is float64:", v.Kind() == reflect.Float64)
fmt.Println("value:", v.Float())
```

打印出
prints

```
type: float64
kind is float64: true
value: 3.4
```

There are also methods like SetInt and SetFloat but to use them we need to understand settability, the subject of the third law of reflection, discussed below.

The reflection library has a couple of properties worth singling out. First, to keep the API simple, the "getter" and "setter" methods of Value operate on the largest type that can hold the value: int64 for all the signed integers, for instance. That is, the Int method of Value returns an int64 and the SetInt value takes an int64; it may be necessary to convert to the actual type involved:

```
var x uint8 = 'x'
v := reflect.ValueOf(x)
fmt.Println("type:", v.Type())                            // uint8.
fmt.Println("kind is uint8: ", v.Kind() == reflect.Uint8) // true.
x = uint8(v.Uint())                                       // v.Uint returns a uint64.
```

The second property is that the Kind of a reflection object describes the underlying type, not the static type. If a reflection object contains a value of a user-defined integer type, as in

```
type MyInt int
var x MyInt = 7
v := reflect.ValueOf(x)
```

the Kind of v is still reflect.Int, even though the static type of x is MyInt, not int. In other words, the Kind cannot discriminate an int from a MyInt even though the Type can.

### The second law of reflection    

#### 2. Reflection goes from reflection object to interface value.    

Like physical reflection, reflection in Go generates its own inverse.

Given a reflect.Value we can recover an interface value using the Interface method; in effect the method packs the type and value information back into an interface representation and returns the result:

```
// Interface returns v's value as an interface{}.
func (v Value) Interface() interface{}
```

As a consequence we can say

```
y := v.Interface().(float64) // y will have type float64.
fmt.Println(y)
```

to print the float64 value represented by the reflection object v.

We can do even better, though. The arguments to fmt.Println, fmt.Printf and so on are all passed as empty interface values, which are then unpacked by the fmt package internally just as we have been doing in the previous examples. Therefore all it takes to print the contents of a reflect.Value correctly is to pass the result of the Interface method to the formatted print routine:

```
fmt.Println(v.Interface())
```

(Why not fmt.Println(v)? Because v is a reflect.Value; we want the concrete value it holds.) Since our value is a float64, we can even use a floating-point format if we want:

```
fmt.Printf("value is %7.1e\n", v.Interface())
```

and get in this case

```
3.4e+00
```

Again, there's no need to type-assert the result of v.Interface() to float64; the empty interface value has the concrete value's type information inside and Printf will recover it.

In short, the Interface method is the inverse of the ValueOf function, except that its result is always of static type interface{}.

Reiterating: Reflection goes from interface values to reflection objects and back again.

### The third law of reflection  

#### 3. To modify a reflection object, the value must be settable.  

The third law is the most subtle and confusing, but it's easy enough to understand if we start from first principles.

Here is some code that does not work, but is worth studying.

```
var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1) // Error: will panic.
```

If you run this code, it will panic with the cryptic message

```
panic: reflect.Value.SetFloat using unaddressable value
```

The problem is not that the value 7.1 is not addressable; it's that v is not settable. Settability is a property of a reflection Value, and not all reflection Values have it.

The CanSet method of Value reports the settability of a Value; in our case,

```
var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println("settability of v:", v.CanSet())
```

prints

```
settability of v: false
```

It is an error to call a Set method on an non-settable Value. But what is settability?

Settability is a bit like addressability, but stricter. It's the property that a reflection object can modify the actual storage that was used to create the reflection object. Settability is determined by whether the reflection object holds the original item. When we say
```
var x float64 = 3.4
v := reflect.ValueOf(x)
```
we pass a copy of x to reflect.ValueOf, so the interface value created as the argument to reflect.ValueOf is a copy of x, not x itself. Thus, if the statement
```
v.SetFloat(7.1)
```
were allowed to succeed, it would not update x, even though v looks like it was created from x. Instead, it would update the copy of x stored inside the reflection value and x itself would be unaffected. That would be confusing and useless, so it is illegal, and settability is the property used to avoid this issue.

If this seems bizarre, it's not. It's actually a familiar situation in unusual garb. Think of passing x to a function:
```
f(x)
```
We would not expect f to be able to modify x because we passed a copy of x's value, not x itself. If we want f to modify x directly we must pass our function the address of x (that is, a pointer to x):
```
f(&x)
```
This is straightforward and familiar, and reflection works the same way. If we want to modify x by reflection, we must give the reflection library a pointer to the value we want to modify.

Let's do that. First we initialize x as usual and then create a reflection value that points to it, called p.
```
var x float64 = 3.4
p := reflect.ValueOf(&x) // Note: take the address of x.
fmt.Println("type of p:", p.Type())
fmt.Println("settability of p:", p.CanSet())
```
The output so far is
```
type of p: *float64
settability of p: false
```
The reflection object p isn't settable, but it's not p we want to set, it's (in effect) *p. To get to what p points to, we call the Elem method of Value, which indirects through the pointer, and save the result in a reflection Value called v:
```
v := p.Elem()
fmt.Println("settability of v:", v.CanSet())
```
Now v is a settable reflection object, as the output demonstrates,
```
settability of v: true
```
and since it represents x, we are finally able to use v.SetFloat to modify the value of x:
```
v.SetFloat(7.1)
fmt.Println(v.Interface())
fmt.Println(x)
```
The output, as expected, is
```
7.1
7.1
```
Reflection can be hard to understand but it's doing exactly what the language does, albeit through reflection Types and Values that can disguise what's going on. Just keep in mind that reflection Values need the address of something in order to modify what they represent.

Structs

In our previous example v wasn't a pointer itself, it was just derived from one. A common way for this situation to arise is when using reflection to modify the fields of a structure. As long as we have the address of the structure, we can modify its fields.

Here's a simple example that analyzes a struct value, t. We create the reflection object with the address of the struct because we'll want to modify it later. Then we set typeOfT to its type and iterate over the fields using straightforward method calls (see package reflect for details). Note that we extract the names of the fields from the struct type, but the fields themselves are regular reflect.Value objects.
```
type T struct {
    A int
    B string
}
t := T{23, "skidoo"}
s := reflect.ValueOf(&t).Elem()
typeOfT := s.Type()
for i := 0; i < s.NumField(); i++ {
    f := s.Field(i)
    fmt.Printf("%d: %s %s = %v\n", i,
        typeOfT.Field(i).Name, f.Type(), f.Interface())
}
```
The output of this program is
```
0: A int = 23
1: B string = skidoo
```
There's one more point about settability introduced in passing here: the field names of T are upper case (exported) because only exported fields of a struct are settable.

Because s contains a settable reflection object, we can modify the fields of the structure.
```
s.Field(0).SetInt(77)
s.Field(1).SetString("Sunset Strip")
fmt.Println("t is now", t)
```
And here's the result:
```
t is now {77 Sunset Strip}
```
If we modified the program so that s was created from t, not &t, the calls to SetInt and SetString would fail as the fields of t would not be settable.

Conclusion

Here again are the laws of reflection:

Reflection goes from interface value to reflection object.
Reflection goes from reflection object to interface value.
To modify a reflection object, the value must be settable.
Once you understand these laws reflection in Go becomes much easier to use, although it remains subtle. It's a powerful tool that should be used with care and avoided unless strictly necessary.

There's plenty more to reflection that we haven't covered — sending and receiving on channels, allocating memory, using slices and maps, calling methods and functions — but this post is long enough. We'll cover some of those topics in a later article.

By Rob Pike
