## gdb&delve调试工具

2年前刚开始看go的时候，一直不明白go是怎么进行debug的，总以为ide里面如同c或者java一样，自带了debug工具，可以设断点查当前变量值什么的。
实际上大概是想多了，并没有完善到这种程度。

现在的话，代码写多了，如果没有合适的debug工具，始终是受到一定的制约。好在在官网介绍了一个叫gdb的工具。

那么我就按他的步骤来看一下这个gdb到底是什么样的用法吧。

首先，要安装gdb，这个就自行解决了。  
windows里面的话，安装MinGW，然后将bin目录添加到环境变量Path中去。  

接着，就要
`Pass the '-w' flag to the linker to omit the debug information`
从字面的意思看是，是用-w这个参数来达到移除debug信息的目的（估计是go自带的debug信息吧）不管了，官方让我怎么做，我就怎么做。
`go build -ldflags "-w" main.go`

main.go是我手写的一个函数
```go
package main
import "fmt"

func main()  {
	var val int8 = 1
	fmt.Println(val)
}
```
接下来，还要关闭gc compiler时产生的内联函数的调用和登记变量
`The code generated by the gc compiler includes inlining of function invocations and registerization of variables. `
其实我也看不懂具体什么意思，不过官方既然让你关，你就关。
`go build -gcflags "-N -l" main.go`

接着，官方又推荐我们设置`GOTRACEBACK=crash`来生成core文件来查看程序崩溃时的堆栈信息
除了crash以外，还有其它的几种方式
```
GOTRACEBACK=none omits the goroutine stack traces entirely. 
GOTRACEBACK=single (the default) behaves as described above. 
GOTRACEBACK=all adds stack traces for all user-created goroutines. 
GOTRACEBACK=system is like “all” but adds stack frames for run-time functions and shows goroutines created internally by the run-time. 
GOTRACEBACK=crash is like “system” but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump.
```
这里不多做描述，心里有个概念即可。

具体的帮助文档地址：  
https://golang.org/doc/gdb （需翻墙）

### 产生Test文件
```
/Users/liudan/Documents/code/reflect/src
hello_test.go	main.go		regexp		src.test
```
目录中必须带有test测试文件。  
然后执行go test -c 产生一个src.text文件

也可以不用，直接用go build -gcflags "-N -l" -o regex gdb.go  

### 启动
gdb src.test

## 更新
GDB我已经弃用，改用derekparker/delve，太棒了，强推！

用法，可见地址  
https://github.com/derekparker/delve/

安装以后加入环境变量，然后dlv便可启动命令，如：dlv debug xxx.go  
之后进入(dlv)命令行

如果你要设置断点，可用命令：b xxx.go:行数  
然后有下例若干简单命令：  
```
(dlv) bp   #查看当前所有断点
(dlv) c    #运行到下一个断点或者程序结尾
(dlv) p a  #打印变量 a 的值
(dlv) n    #单步执行代码
(dlv) set a=1  #设置变量a 的值
```

更多的命令可以执行(dlv)help查看。
