
接下来，我准备尝自己写一个简单的RPC应用。  
首先，我仍然写一个Go的服务端。  

不过这次的环境和之前有所不同，这次我放在Linux服务器下面。并且这次实战的主要诉求是以Php做为客户端与Go服务端的交互：  

安装Go环境：  
```
yum install go
```

```
[root@6c6aa7fb57ef /]# go version
go version go1.8.3 linux/amd64
```

安装Php版本的protobuf  
`wget https://github.com/google/protobuf/releases/download/v3.4.1/protobuf-php-3.4.1.tar.gz`
下载，解压，安装
```
./configure
make && make install
```

完成  
```
[root@6c6aa7fb57ef protobuf-3.4.1]# protoc --version
libprotoc 3.4.0
```

写一个proto文件：  
```go
//redis.proto
syntax = "proto3";

package redis;

service Redis {
  rpc Command (RedisRequest) returns (RedisReply) {}
}

message RedisRequest {
  string action = 1;
  string param = 2;
}

// The response message containing the greetings
message RedisReply {
  string result = 1;
}

```
这个项目会有redis有关系，所以我起名叫redis。在proto里面，我主要实现一个叫Command的方法，这个方法需要输入两个参数：action（字符）和param（字符）  
返回一个参数：result（字符） 
`很简单`

写好之后，编译`选用的是php插件`：`protoc redis.proto --php_out=plugins=grpc:.`  
完成后得到两个Php文件：  
```
[root@6c6aa7fb57ef grpc]# ls
GPBMetadata  Redis  redis.proto
[root@6c6aa7fb57ef grpc]# cd Redis/
[root@6c6aa7fb57ef Redis]# ls
RedisReply.php  RedisRequest.php
```

先不管它们，因为我是要用Go作为服务器，所以还要进行Go的设置。  
`go get -u github.com/golang/protobuf/protoc-gen-go`  
安装好后，我在我的`/root/go/bin/protoc-gen-go`得到了这个库。  

接着，用这个Go的proto插件同样基于redis.proto文件生成一套标准代码。  
`protoc redis.proto --go_out=plugins=grpc:.`  
产生的`redis.pb.go`  

我把这个go文件复制到我的项目中去。  

在复制前，我还需要进行Go的Grpc库的安装，和windows环境不同的是，因为墙的关系，我是手动安装的  

先用go env查看一下你的GOPATH的目录：  

再去相应的目录建立你的库目录：  

```go
$mkdir -p $GOPATH/src/golang.org/x/
$cd $GOPATH/src/golang.org/x/
$git clone https://github.com/golang/net.git net 
$go install net
```
按这个方法，一共要装四个库：  
```
git clone https://github.com/golang/net.git net
go install net
https://github.com/golang/text.git net
https://github.com/grpc/grpc-go.git grpc
https://github.com/google/go-genproto.git genproto
```

接着，就可以写代码了，具体的代码在这里就不贴出来了，可以参考下面的地址的源文件：

<a href="https://github.com/gundamzaku/golang_study_note/tree/master/grpc/action_in_php_code/redis/src">服务端的实现</a>  

<a href="https://github.com/gundamzaku/golang_study_note/tree/master/grpc/action_in_php_code/redis_client/src/">客户端的实现</a>  


把两段源代码copy到linux下面用go build编译一下即可执行，具体的就不敷多述。  
不过需要注意的是，这个时候编译仍然会报错：  
```
main.go:5:2: cannot find package "proto" in any of:
        /usr/lib/golang/src/proto (from $GOROOT)
        /root/go/src/proto (from $GOPATH)
```
这是因为proto这个目录没有加入到GOPATH中去，所以要加一下：  
设置GOPATH
```
vim ~/.bash_profile
export GOPATH=/root/go:/data/go
```
data/go就是我的目录，他会自动找里面的src目录  

然后就可以正常编译了  

先执行服务端：  
```
redis server start:
err
regist:
```

再执行客户端：
```
redis client start:
<nil>
make connect
make connect end
send commond
<nil>
2017/10/14 01:55:13 Greeting: Action is get  Param is 2017
Greeting: %s Action is get  Param is 2017
```

大功告成，不过目录我为了测试，仍然还是之前的Go与Go的通信。接下来就要实现Php与Go的通信了。  

至于Php下面怎么用……首先，第一步要安装Php（废话）  

接着，要安装Php的grpc扩展（这个不是废话了）  

`https://grpc.io/docs/quickstart/php.html`  

这是官方的教程，不过很遗憾，我的环境是centos，所以要看centos的教程`https://github.com/grpc/grpc/tree/master/src/php#build-from-source`  

先克隆：`git clone -b $(curl -L https://grpc.io/release) https://github.com/grpc/grpc`  

然后安装gRpc的核心库  
```
$ cd grpc
$ git pull --recurse-submodules && git submodule update --init --recursive
$ make
$ sudo make install
```
结果直接就报错了，每次都会在安装的时候报各种错误，不过Go的错误大多还是因为墙的关系。  

先看一个错误：  
```
No package 'libcares' found
```
是缺一个包，直接用`yum install c-ares-devel`安装。  

接着仍然有错：  
```
DEPENDENCY ERROR

You are missing system dependencies that are essential to build grpc,
and the third_party directory doesn't have them:

  cares

Installing the development packages for your system will solve
this issue. Please consult INSTALL to get more information.

If you need information about why these tests failed, run:

  make run_dep_checks

Additionally, since you are in a git clone, you can download the
missing dependencies in third_party by running the following command:

  git submodule update --init

make: *** [stop] Error 1
```
按它的提示，执行检查：  
```
[root@6c6aa7fb57ef grpc]# make run_dep_checks
pkg-config --atleast-version=1.0.2 openssl || true
pkg-config --atleast-version=1.0.1 openssl || true
pkg-config --exists zlib || true
cc -Ithird_party/googletest/googletest/include -Ithird_party/googletest/googlemock/include -Ithird_party/boringssl/include -g -Wall -Wextra -Werror -Wno-long-long -Wno-unused-parameter -DOSATOMIC_USE_INLINED=1 -O2 -fPIC -I. -Iinclude -I/tmp/grpc/gens -DNDEBUG -DINSTALL_PREFIX=\"/usr/local\"       -std=c99 -Wsign-conversion -Wconversion -Wshadow    -o /dev/null test/build/perftools.c -lprofiler -g  -fPIC -Llibs/opt -pthread       || true
test/build/perftools.c:19:33: fatal error: gperftools/profiler.h: No such file or directory
 #include <gperftools/profiler.h>
 ```
发现第三方库的perftools有错，得了，我找到这个库自己安装一下吧。  
`git clone https://github.com/gperftools/gperftools`
下载完成后进目录执行：`./autogen.sh`  
然后：  
```go
./configure
make
make check(可选)
make install
make clean
```

检查通过了  
``` 
[root@6c6aa7fb57ef grpc]# make run_dep_checks
pkg-config --atleast-version=1.0.2 openssl || true
pkg-config --atleast-version=1.0.1 openssl || true
pkg-config --exists zlib || true
cc -Ithird_party/googletest/googletest/include -Ithird_party/googletest/googlemock/include -Ithird_party/boringssl/include -g -Wall -Wextra -Werror -Wno-long-long -Wno-unused-parameter -DOSATOMIC_USE_INLINED=1 -O2 -fPIC -I. -Iinclude -I/tmp/grpc/gens -DNDEBUG -DINSTALL_PREFIX=\"/usr/local\" -DGRPC_HAVE_PERFTOOLS       -std=c99 -Wsign-conversion -Wconversion -Wshadow    -o /dev/null test/build/perftools.c -lprofiler -g  -fPIC -Llibs/opt -pthread       || true
pkg-config --atleast-version=3.0.0 protobuf || true
protoc --version | grep -q libprotoc.3 || true
pkg-config --atleast-version=1.11.0 libcares || true
```
可是仍然编译不了。  
```
[root@6c6aa7fb57ef grpc]# git submodule update --init
Cloning into 'third_party/boringssl-with-bazel'...
fatal: unable to access 'https://boringssl.googlesource.com/boringssl/': Failed to connect to 2404:6800:4008:c03::52: Network is unreachable
Clone of 'https://boringssl.googlesource.com/boringssl' into submodule path 'third_party/boringssl-with-bazel' failed
```
见鬼……在网上查了一下，原来这个gRpc的库里有一个init的操作（就是上面的），而这个操作基于一个叫.gitmodules的文件来下载一些第三方插件。  
